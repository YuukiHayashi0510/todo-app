// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: staff.sql

package rdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSearchStaff = `-- name: CountSearchStaff :one
SELECT 
    COUNT(*) as total_count
FROM staff
WHERE
    CASE 
        WHEN $1::text = 'all' THEN true
        WHEN $1::text = 'active' THEN deleted_at IS NULL
        WHEN $1::text = 'in_active' THEN deleted_at IS NOT NULL
    END
    AND ($2::bigint = 0 OR organization_id = $2::bigint)
    AND ($3::text = '' OR email LIKE '%' || $3::text || '%')
    AND ($4::text = '' OR staff_name LIKE '%' || $4::text || '%')
    AND ($5::timestamp IS NULL OR created_at >= $5::timestamp)
    AND ($6::timestamp IS NULL OR created_at <= $6::timestamp)
`

type CountSearchStaffParams struct {
	SearchStatus   string
	OrganizationID int64
	Email          string
	StaffName      string
	CreatedAtStart pgtype.Timestamp
	CreatedAtEnd   pgtype.Timestamp
}

// 検索結果の総件数を取得
func (q *Queries) CountSearchStaff(ctx context.Context, arg CountSearchStaffParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchStaff,
		arg.SearchStatus,
		arg.OrganizationID,
		arg.Email,
		arg.StaffName,
		arg.CreatedAtStart,
		arg.CreatedAtEnd,
	)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const createStaff = `-- name: CreateStaff :one
INSERT INTO staff (
    organization_id,
    email,
    staff_name
) VALUES (
    $1::bigint,
    $2::text,
    $3::text
)
RETURNING staff_id, organization_id, email, staff_name, created_at, updated_at, deleted_at
`

type CreateStaffParams struct {
	OrganizationID int64
	Email          string
	StaffName      string
}

// スタッフの新規作成
func (q *Queries) CreateStaff(ctx context.Context, arg CreateStaffParams) (Staff, error) {
	row := q.db.QueryRow(ctx, createStaff, arg.OrganizationID, arg.Email, arg.StaffName)
	var i Staff
	err := row.Scan(
		&i.StaffID,
		&i.OrganizationID,
		&i.Email,
		&i.StaffName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const searchStaff = `-- name: SearchStaff :many
SELECT 
    staff_id,
    organization_id,
    email,
    staff_name,
    created_at,
    updated_at,
    deleted_at
FROM staff
WHERE
    CASE 
        WHEN $1::text = 'all' THEN true
        WHEN $1::text = 'active' THEN deleted_at IS NULL
        WHEN $1::text = 'in_active' THEN deleted_at IS NOT NULL
    END
    AND ($2::bigint = 0 OR organization_id = $2::bigint)
    AND ($3::text = '' OR email LIKE '%' || $3::text || '%')
    AND ($4::text = '' OR staff_name LIKE '%' || $4::text || '%')
    AND ($5::timestamp IS NULL OR created_at >= $5::timestamp)
    AND ($6::timestamp IS NULL OR created_at <= $6::timestamp)
ORDER BY staff_id DESC
LIMIT CAST($8 AS INTEGER)
OFFSET CAST($7 AS INTEGER)
`

type SearchStaffParams struct {
	SearchStatus   string
	OrganizationID int64
	Email          string
	StaffName      string
	CreatedAtStart pgtype.Timestamp
	CreatedAtEnd   pgtype.Timestamp
	Offset         int32
	Limit          int32
}

// スタッフの検索クエリ
func (q *Queries) SearchStaff(ctx context.Context, arg SearchStaffParams) ([]Staff, error) {
	rows, err := q.db.Query(ctx, searchStaff,
		arg.SearchStatus,
		arg.OrganizationID,
		arg.Email,
		arg.StaffName,
		arg.CreatedAtStart,
		arg.CreatedAtEnd,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Staff{}
	for rows.Next() {
		var i Staff
		if err := rows.Scan(
			&i.StaffID,
			&i.OrganizationID,
			&i.Email,
			&i.StaffName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
